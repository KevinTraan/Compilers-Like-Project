Constant string literal values are valid for length operation.
This is a valid program.

Expected Output:
 oSymbolStkPush(syProcedure)
 oSymbolTblPushScope
 oCountPush(three)
  oSymbolStkPushLocalIdentifier
  oSymbolStkSetKind(syVariable)
  oTypeStkPush(tpFile)
  oTypeStkLinkToStandardType(stdText)
  oSymbolStkEnterTypeReference
  oValuePush(two)
   .tFileDescriptor
   oAllocateAlignOnWord
   oSymbolStkEnterDataAddress
   .tLiteralInteger
   oEmitValue
   .tFileBind
   .tLiteralAddress
   oEmitDataAddress
   % value emitted 0
   .tStoreInteger
   oAllocateDescriptor
  oSymbolTblEnter
  oSymbolStkPop
  oTypeStkPop
  oValuePop
 oCountPop
   oSymbolStkPushLocalIdentifier
   .tInitialValue
     oSymbolStkPush(syExpression)
      .tSkipString
      oFixPushForwardBranch
      oEmitNullAddress
      % value emitted -32767
      .tStringData
      oValuePushStringLength
      oEmitValue
      oValuePop
      oValuePushCodeAddress
      oValueNegate
      oEmitString
      % value emitted 104
      % value emitted 101
      % value emitted 108
      % value emitted 108
      % value emitted 111
      % value emitted 0
      oFixPopForwardBranch
      oTypeStkPush(tpChar)
      oTypeStkLinkToStandardType(stdChar)
     .tLiteralAddress
     .tFetchChar
     oEmitValue
     oValuePop
     .tLength
     oTypeStkPush(tpInteger)
     oTypeStkSwap
     oTypeStkPop
     oSymbolStkSetKind(syExpression)
   oSymbolStkPop
    oTypeTblEnter
    oSymbolStkSetKind(syVariable)
     oAllocateAlignOnWord
     oSymbolStkEnterDataAddress
     oAllocateVariable
    oSymbolStkEnterTypeReference
    oSymbolTblEnter
   .tLiteralInteger
   .tLiteralAddress
    .tStoreInteger
   oTypeStkPop
   oSymbolStkPop
 oSymbolTblPopScope
 oSymbolStkPop
 .tTrapBegin
 .tTrap
 oEmitTrapKind(trHalt)
 % value emitted 0
